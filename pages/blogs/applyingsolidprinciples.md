---
layout: post
title: 'Applying SOLID Design Principles'
author: Thomas Wood
tagline: 'Applying SOLID Design Principles'
description: Applying SOLID Design Principles
---

<p align="left">
  In object-oriented programming it is easy to make a mess. Classes can become bloated and reach incomprehensible sizes that would make any software engineer blush. It happens. For real, it happens. To people. Even to people who are writing blogs about it that you are reading right now. While developing my own games, I have largely favoured moving quickly and breaking stuff over writing clean, maintainable, extensible, non-messy code. When working on your own and prototyping ideas this can be a great approach! After all, any time you spend perfecting a system's architecture could be wasted as the design of what you're working on inevitably changes and you things throw out. Eventually though there comes a time where you know a system is here to stay. For example, I have now used the same interaction system in three of my projects. It is time for me to make the code comprehensible and to clean up my mess. To do that I am going to apply <a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a> design principles.<br/><br/> 
  
  <i>If you want to see the final code it can be found here. For a more in depth look, the full repo (including all commits/changes I made) can be found over <a href="https://github.com/twood27897/Interactor-Example/tree/main/Assets/_TOOLBOX/Interactables">here</a>. The rest of this blog is going to be a high level overview of my thoughts as I applied the SOLID principles to my code.</i><br/><br/>

  When I have worked in teams in the past, SOLID has been a great way to architect large systems. A go to approach that pushes you to breakdown your code into sizeable chunks while also reducing dependencies, SOLID is pretty spot on for helping teams to write and maintain large codebases. The first principle of SOLID is the <i>Single Responsibility Principle</i>. A great way to understand how to breakdown large, complex systems, it says each class you create should only have one responsibility. Now, just by giving my interaction system's <i>Interactor</i> class a side ways glance I can tell it has more than one responsibility. In fact, it has three real big ones:<br/>
  
  <ol type="1"><li>Targeting interactable objects</li><li>Triggering interactions with interactable objects</li><li>Visualising available interactable objects</li></ol><br/>

  By separating out these responsibilities, I am well on the way to cleaning up the mess of my interaction system. I've created two new classes - one for targeting interactables and one for visualising interactables - and have left the responsibility of triggering interactions to the <i>Interactor</i> class. With each responsibility now existing in a single class, the code becomes a lot more readable and maintainable. Even working on my own, it becomes easier to track bugs down and make small changes. Instead of needing to refamiliarise myself with the whole system everytime I am working on it, I can now go straight to the code responsible for what I am working on (e.g. visualisation, targeting or triggering) and get stuck in. Everything is a little simpler.<br/><br/>

  The fifth principle of SOLID (the <i>Dependency Inversion Principle</i>) states to "depend upon abstractions, not concretes". This means that when classes interact/depend upon one another they should not do so directly. Instead, there should be an abstraction layer between them. By abstracting classes you can break hard dependencies between modules in large codebases, decoupling code. You are also able to change behind the scenes implementations of a system more easily and, best of all I reckon, you have to really think about and understand the public facing interface of your code before you can properly abstract it. For my interaction system, I created interfaces for my <i>Interactor</i>, <i>Interactable</i> and targeting class. Currently, my visualisation class does not need an abstraction layer as it does not need a public interface - it purely reads and displays available interactions to the screen and shouldn't have anything that depends upon it.<br/><br/>

  Now I have broken down and abstracted my interaction system, the flexibility the SOLID principles create stands out. If I wanted to create a whole new way of targeting interactables I could simply create a new targeting class that uses my targeting interface. I could then have different interactors use different targeting systems. The same applies to visualising interactables. By creating a new visualisation class that reads from the interactor interface I could have different interactors visualise their interactions entirely differently (or not at all). If I was making a multiplayer game it would be easy to make sure the interactions of other players are not visualised, I would simply remove the visualisation class.<br/><br/>
</p>
