---
layout: post
title: 'Applying SOLID Design Principles'
author: Thomas Wood
tagline: 'Applying SOLID Design Principles'
description: Applying SOLID Design Principles
---

<p align="left">
  In object-oriented programming it is easy to make a mess. Classes can become bloated and reach incomprehensible sizes that would make any software engineer blush. It happens. Even to people who are writing blogs about it that you are reading right now. While developing my own games, I have largely favoured moving quickly and breaking stuff over writing clean, maintainable, extensible, non-messy code. When working on your own and prototyping ideas this can be a great approach! After all, any time you spend perfecting a system's architecture could be wasted as the design of what you're working on inevitably changes and you throw things out. Eventually though there comes a time where you know a system is here to stay. For example, I have now used the same interaction system in three of my projects. It is time for me to make the code comprehensible and to clean up my mess. To do that I am going to apply <a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a> design principles.<br/><br/> 
  
  <i>If you want to see the final code it can be found <a href="https://github.com/twood27897/Applying-SOLID-Design-Principles-Final-Code">here</a>. For a more in depth look, the full repo (including all commits/changes I made) can be found over <a href="https://github.com/twood27897/Applying-SOLID-Design-Principles-Full-Repo/tree/main/Assets/_TOOLBOX/Interactables">here</a>. The rest of this blog is going to be a high level overview of my thoughts as I applied the SOLID principles to my code.</i><br/><br/>

  When I have worked in teams in the past, SOLID has been a great way to architect large systems. A go to approach that pushes you to breakdown your code into sizeable chunks while also reducing dependencies, SOLID is pretty spot on for helping teams to write and maintain large codebases. The first principle of SOLID is the <i>Single Responsibility Principle</i>. A great way to understand how to breakdown large, complex systems, it says each class you create should only have one responsibility. Now, just by giving my interaction system's <i>Interactor</i> class a side ways glance I can tell it has more than one responsibility. In fact, it has three real big ones:<br/>
  
  <ol type="1"><li>Targeting interactable objects</li><li>Triggering interactions with interactable objects</li><li>Visualising available interactable objects</li></ol><br/>

  By separating out these responsibilities, I am well on the way to cleaning up the mess of my interaction system. I've created two new classes - one for targeting interactables and one for visualising interactables - and have left the responsibility of triggering interactions to the <i>Interactor</i> class. With each responsibility now existing in a single class, the code becomes a lot more readable and maintainable. Even working on my own, it becomes easier to track bugs down and make small changes. Instead of needing to refamiliarise myself with the whole system everytime I am working on it, I can now go straight to the code responsible for what I am working on (e.g. visualisation, targeting or triggering) and get stuck in. Everything is a little simpler.<br/><br/>

  The fifth principle of SOLID (the <i>Dependency Inversion Principle</i>) states to "depend upon abstractions, not concretes". This means that when classes interact/depend upon one another they should not do so directly. Instead, there should be an abstraction layer between them. By abstracting classes you can break hard dependencies between modules in large codebases, decoupling code. You are also able to change behind the scenes implementations of a system more easily and, best of all I reckon, you have to really think about and understand the public facing interface of your code before you can properly abstract it. For my interaction system, I created interfaces for my <i>Interactor</i>, <i>Interactable</i> and targeting class. Currently, my visualisation class does not need an abstraction layer as it does not need a public interface - it purely reads and displays available interactions to the screen and shouldn't have anything that depends upon it.<br/><br/>

  Now I have broken down and abstracted my interaction system, the flexibility the SOLID principles create stands out. If I wanted to create a whole new way of targeting interactables I could simply create a new targeting class that uses my targeting interface. I could then have different interactors use different targeting systems. The same applies to visualising interactables. By creating a new visualisation class that reads from the interactor interface I could have different interactors visualise their interactions entirely differently (or not at all). If I was making a multiplayer game, it would be easy to make sure the interactions of other players are not visualised, I would simply remove the visualisation class from the remote player objects.<br/><br/>

  The last SOLID principle I took into account as I refactored my interaction system code was the fourth - the <i>Interface Segregation Principle</i>. Like it's name suggests, this is all about considering how the interfaces/abstractions you use can be distilled into their simplest forms with the aim of "clients not being force to depend on upon interfaces they do not use". In a way this principle is similar to the <i>Single Responsibility Principle</i> but with a focus on interfaces/abstractions. I've found this principle is useful as when creating an interface, it's easy to just fill it with any public facing functions you may possibly need. My first pass <i>InteractableInterface</i>, for example, has three main uses/pieces of functionality split across seven functions:<br/><br/>

  <ol type="1"><li>Interaction functionality (represented by the <i>Interact</i>, <i>CanInteract</i> and <i>GetPosition</i> functions)</li><li>Functionality for being targeted reactions (represented by the <i>Target</i> and <i>Untarget</i> functions)</li><li>Functionality for being made available reactions (represented by the <i>Available</i> and <i>Unavailable</i> functions)</li></ol><br/>

  All interactable objects implementing the <i>InteractableInterface</i> have interaction functionality but many don't want to react to being targeted or made available. Often, this leaves interactable objects with bloat as they implement empty targeting/available reaction functions. Using the <i>Interface Segregation Principle</i> the path forward is clear - this shouldn't be one interface, it should be multiple:<br/><br/>

  <ol type="1"><li>The <i>InteractableInterface</i> for interaction functionality</li><li>The <i>InteractableTargetedReactionsInterface</i> for functionality for reactions to being targeted</li><li>The <i>InteractableAvailableReactionsInterface</i> for functionality for reactions to being made available</li></ol><br/>

  The various functions can now sit in their relevant functionality's interface and objects will no longer end up implementing them unless they are needed. With this change, as with many made by using SOLID principles, there is a risk of over compartmentalizing your code. I find that if you truly section every class and interface into it's smallest possible version you can end up with a code base that is unreadable in the opposite fashion to where we started; no longer containing a few overly large files but instead many tiny little files that continually need to be jumped between and held in the head of the engineer. This can create it's own challenges. For every codebase/system, a different balance needs to be found to make sure you don't end up in one extreme or the other.<br/><br/>

  I am going to leave the final two SOLID principles for now as they didn't really impact the refactoring of my interaction code. While the SOLID principles are a package they aren't all relevant to every problem. You must pick and choose when to use them.<br/><br/>
  
  And that about wraps up this blog. I could write a lot more on where I think these principles shine and where they falter when programming games but I will leave that for another day. Maybe it's for a blog I'll write in the future.<br/><br/>

Take a look at the final code: <a href="https://github.com/twood27897/Applying-SOLID-Design-Principles-Final-Code">github.com/twood27897/Applying-SOLID-Design-Principles-Final-Code</a><br/>
  Or the full repo (with changelists and history): <a href="https://github.com/twood27897/Applying-SOLID-Design-Principles-Full-Repo/tree/main/Assets/_TOOLBOX/Interactables">github.com/twood27897/Applying-SOLID-Design-Principles-Full-Repo/tree/main/Assets/_TOOLBOX/Interactables</a><br/>
</p>
